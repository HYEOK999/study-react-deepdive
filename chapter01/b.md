# 01장: 리액트 개발을 위해 꼭 알아야 할 자바스크립트

책을 읽기 전에 자바스크립트에 대한 기본적인 지식을 다루는 장입니다.
이 장에서는 리액트를 사용하면서 자주 사용하는 자바스크립트 문법과 개념을 간단히 정리합니다.

<br>

- [01장: 리액트 개발을 위해 꼭 알아야 할 자바스크립트](#01장-리액트-개발을-위해-꼭-알아야-할-자바스크립트)
  - [1.1 자바스크립트의 동등 비교](#11-자바스크립트의-동등-비교)
    - [1.1.1 자바스크립트의 데이터 타입](#111-자바스크립트의-데이터-타입)
    - [1.1.2 값을 저장하는 방식의 차이](#112-값을-저장하는-방식의-차이)
    - [1.1.3 자바스크립트의 또 다른 비교 공식, `Object.is`](#113-자바스크립트의-또-다른-비교-공식-objectis)
    - [1.1.4 리액트에서의 동등 비교](#114-리액트에서의-동등-비교)
    - [1.1.5 정리](#115-정리)
  - [1.2 함수](#12-함수)
    - [1.2.1 함수란 무엇인가?](#121-함수란-무엇인가)
    - [1.2.2 함수를 정의하는 4가지 방법](#122-함수를-정의하는-4가지-방법)
    - [1.2.3 다양한 함수 살펴보기](#123-다양한-함수-살펴보기)
    - [1.2.4 함수를 만들 때 주의해야 할 사항](#124-함수를-만들-때-주의해야-할-사항)
    - [1.2.5 정리](#125-정리)
  - [1.3 클래스](#13-클래스)
    - [1.3.1 클래스란 무엇인가?](#131-클래스란-무엇인가)
    - [1.3.2 클래스와 함수의 관계](#132-클래스와-함수의-관계)
    - [1.3.3 정리](#133-정리)
  - [1.4 클로저](#14-클로저)
    - [1.4.1 클로저의 정의](#141-클로저의-정의)
    - [1.4.2 변수의 유효 범위, 스코프](#142-변수의-유효-범위-스코프)
    - [1.4.3 클로저의 활용](#143-클로저의-활용)
    - [1.4.4 주의할 점](#144-주의할-점)
    - [1.4.5 정리](#145-정리)
  - [1.5 이벤트 루프와 비동기 통신의 이해](#15-이벤트-루프와-비동기-통신의-이해)
    - [1.5.1 싱글 스레드 자바스크립트](#151-싱글-스레드-자바스크립트)
    - [1.5.2 이벤트 루프란?](#152-이벤트-루프란)
    - [1.5.3 태스크 큐와 마이크로 태스크 큐](#153-태스크-큐와-마이크로-태스크-큐)
    - [1.5.4 정리](#154-정리)
  - [1.6 리액트에서 자주 사용하는 자바스크립트 문법](#16-리액트에서-자주-사용하는-자바스크립트-문법)
    - [1.6.1 구조 분해 할당](#161-구조-분해-할당)
    - [1.6.2 전개 구문](#162-전개-구문)
    - [1.6.3 객체 초기자](#163-객체-초기자)
    - [1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach](#164-array-프로토타입의-메서드-map-filter-reduce-foreach)
    - [1.6.5 삼항 조건 연산자](#165-삼항-조건-연산자)
    - [1.6.6 정리](#166-정리)
  - [1.7 선택이 아닌 필수, 타입스크립트](#17-선택이-아닌-필수-타입스크립트)
    - [1.7.1 타입스크립트란?](#171-타입스크립트란)
    - [1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법](#172-리액트-코드를-효과적으로-작성하기-위한-타입스크립트-활용법)
    - [1.7.3 타입스크립트 전환 가이드](#173-타입스크립트-전환-가이드)
    - [1.7.4 정리](#174-정리)

<br>

## 1.1 자바스크립트의 동등 비교

### 1.1.1 자바스크립트의 데이터 타입

1. 원시 타입

   - 객체가 아닌 모든 타입: 숫자, 문자열, 불리언, null, undefined, 심볼

2. 객체 타입
   - 7가지 원시 타입 이외의 모든 것: 객체, 배열, 함수 등

### 1.1.2 값을 저장하는 방식의 차이

- 원시 타입: 변경 불가능한 형태로 저장, 값을 복사할 때 값 자체를 복사
- 객체 타입: 변경 가능한 형태로 저장, 값을 복사할 때 참조를 복사

  ```javascript
  const a = 1;
  const b = a;
  console.log(a, b, a === b); // 1 1 true
  ```

  ```javascript
  const a = { x: 1 };
  const b = a;
  console.log(a, b, a === b); // { x: 1 } { x: 1 } true
  ```

  ```javascript
  const a = { x: 1 };
  const b = { x: 1 };
  console.log(a, b, a === b); // { x: 1 } { x: 1 } false
  ```

### 1.1.3 자바스크립트의 또 다른 비교 공식, `Object.is`

- `==` vs `Object.is`
  - ==(비교 연산자): 같은 타입이 아니라면 강제로 형변환(type casting)을 한 후에 비교
  - Obect.is: 같은 타입이 아니라면 형변환을 하지 않고 값을 비교
- `===` vs `Object.is`
  - `===`(엄격한 비교 연산자) : 타입 형변환을 하지 않고 값을 비교
  - `Object.is` : `===`와 동일한 결과를 반환하지만, `===`와 다른 결과를 반환하는 경우도 있음

```javascript
-0 === +0; // true
Object.is(-0, +0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, Nan); // true
```

- `Object.is`는 `===`와 동일한 결과를 반환하지만, `===`와 다른 결과를 반환하는 경우도 있음

  ```javascript
  console.log(Object.is(0, -0)); // false
  console.log(Object.is(NaN, NaN)); // true
  ```

- `Object.is`는 `===`와 다르게 동작하는 경우가 많아서 사용을 권장하지 않음
- `===`를 사용하면서 `0`과 `-0`, `NaN`과 `NaN`을 구분해야 하는 경우는 `Object.is`를 사용하면 됨

### 1.1.4 리액트에서의 동등 비교

- 리액트에서는 Object.is 기반의 `shallowEqual 함수`를 사용
- `shallowEqual 함수`는 두 개의 객체를 비교할 때 얕은 비교를 하기 때문에, 객체 내부의 값이 변경되었는지 확인할 수 없음

```javascript
const a = { x: 1, y: 1 };
const b = { x: 1, y: 1 };
console.log(shallowEqual(a, b)); // true
```

- `Object.is`를 통해 먼저 비교한 뒤 내부의 값이 변경되었는지 확인하는 방법을 사용

```javascript
const a = { x: 1, y: 1 };

const b = { ...a, y: 1 };
console.log(shallowEqual(a, b)); // true

const c = { ...a, y: 2 };
console.log(shallowEqual(a, c)); // false
```

### 1.1.5 정리

<br>

## 1.2 함수

### 1.2.1 함수란 무엇인가?

- 함수는 특정 기능을 하나의 단위로 묶어 놓은 것
- 함수를 사용하면 코드의 재사용성이 높아지고, 유지보수가 쉬워짐

```javascript
function add(a, b) {
  return a + b;
}

const sum = add(1, 2);
console.log(sum); // 3
```

### 1.2.2 함수를 정의하는 4가지 방법

1. 함수 선언문
   - 함수 선언문은 함수 이름을 반드시 사용해야 함
   - 함수 선언문은 호이스팅(hoisting)이 발생
   - 호이스팅: 함수 선언문이 코드의 최상단으로 끌어올려지는 현상
   - 함수 선언문은 함수 이름을 반드시 사용해야 하기 때문에 익명 함수를 만들 수 없음
   - 함수 선언문은 일반적으로 함수의 기능을 정의할 때 사용
   ```javascript
   function add(a, b) {
     return a + b;
   }
   ```
2. 함수 표현식
   - 함수 표현식은 함수 이름을 사용하지 않아도 됨
   - 함수 표현식은 호이스팅이 발생하지 않음
   - 함수 표현식은 익명 함수를 만들 수 있음
   - 함수 표현식은 일반적으로 함수를 변수에 할당할 때 사용
   ```javascript
   const add = function (a, b) {
     return a + b;
   };
   ```
3. 화살표 함수

   - 화살표 함수는 함수 표현식을 간결하게 만들어 줌
   - 화살표 함수는 항상 익명 함수로 정의
   - arguments 객체를 사용할 수 없음
   - this, super, new.target, constructor를을 사용할 수 없음

   ```javascript
   const add = (a, b) => {
     return a + b;
   };
   ```

4. Function 생성자 함수
   ```javascript
   const add = new Function("a", "b", "return a + b");
   ```

### 1.2.3 다양한 함수 살펴보기

### 1.2.4 함수를 만들 때 주의해야 할 사항

### 1.2.5 정리

<br>

## 1.3 클래스

### 1.3.1 클래스란 무엇인가?

### 1.3.2 클래스와 함수의 관계

### 1.3.3 정리

<br>

## 1.4 클로저

### 1.4.1 클로저의 정의

### 1.4.2 변수의 유효 범위, 스코프

### 1.4.3 클로저의 활용

### 1.4.4 주의할 점

### 1.4.5 정리

<br>

## 1.5 이벤트 루프와 비동기 통신의 이해

### 1.5.1 싱글 스레드 자바스크립트

### 1.5.2 이벤트 루프란?

### 1.5.3 태스크 큐와 마이크로 태스크 큐

### 1.5.4 정리

<br>

## 1.6 리액트에서 자주 사용하는 자바스크립트 문법

### 1.6.1 구조 분해 할당

### 1.6.2 전개 구문

### 1.6.3 객체 초기자

### 1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach

### 1.6.5 삼항 조건 연산자

### 1.6.6 정리

<br>

## 1.7 선택이 아닌 필수, 타입스크립트

### 1.7.1 타입스크립트란?

### 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법

### 1.7.3 타입스크립트 전환 가이드

### 1.7.4 정리
