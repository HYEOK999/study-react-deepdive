# 01장: 리액트 개발을 위해 꼭 알아야 할 자바스크립트

책을 읽기 전에 자바스크립트에 대한 기본적인 지식을 다루는 장입니다.
이 장에서는 리액트를 사용하면서 자주 사용하는 자바스크립트 문법과 개념을 간단히 정리합니다.

<br>

- [01장: 리액트 개발을 위해 꼭 알아야 할 자바스크립트](#01장-리액트-개발을-위해-꼭-알아야-할-자바스크립트)
  - [1.1 자바스크립트의 동등 비교](#11-자바스크립트의-동등-비교)
    - [1.1.1 자바스크립트의 데이터 타입](#111-자바스크립트의-데이터-타입)
    - [1.1.2 값을 저장하는 방식의 차이](#112-값을-저장하는-방식의-차이)
    - [1.1.3 자바스크립트의 또 다른 비교 공식, Object.is](#113-자바스크립트의-또-다른-비교-공식-objectis)
    - [1.1.4 리액트에서의 동등 비교](#114-리액트에서의-동등-비교)
    - [1.1.5 정리](#115-정리)
  - [1.2 함수](#12-함수)
    - [1.2.1 함수란 무엇인가?](#121-함수란-무엇인가)
    - [1.2.2 함수를 정의하는 4가지 방법](#122-함수를-정의하는-4가지-방법)
    - [1.2.3 다양한 함수 살펴보기](#123-다양한-함수-살펴보기)
    - [1.2.4 함수를 만들 때 주의해야 할 사항](#124-함수를-만들-때-주의해야-할-사항)
    - [1.2.5 정리](#125-정리)
  - [1.3 클래스](#13-클래스)
    - [1.3.1 클래스란 무엇인가?](#131-클래스란-무엇인가)
    - [1.3.2 클래스와 함수의 관계](#132-클래스와-함수의-관계)
    - [1.3.3 정리](#133-정리)
  - [1.4 클로저](#14-클로저)
    - [1.4.1 클로저의 정의](#141-클로저의-정의)
    - [1.4.2 변수의 유효 범위, 스코프](#142-변수의-유효-범위-스코프)
    - [1.4.3 클로저의 활용](#143-클로저의-활용)
    - [1.4.4 주의할 점](#144-주의할-점)
    - [1.4.5 정리](#145-정리)
  - [1.5 이벤트 루프와 비동기 통신의 이해](#15-이벤트-루프와-비동기-통신의-이해)
    - [1.5.1 싱글 스레드 자바스크립트](#151-싱글-스레드-자바스크립트)
    - [1.5.2 이벤트 루프란?](#152-이벤트-루프란)
    - [1.5.3 태스크 큐와 마이크로 태스크 큐](#153-태스크-큐와-마이크로-태스크-큐)
    - [1.5.4 정리](#154-정리)
  - [1.6 리액트에서 자주 사용하는 자바스크립트 문법](#16-리액트에서-자주-사용하는-자바스크립트-문법)
    - [1.6.1 구조 분해 할당](#161-구조-분해-할당)
    - [1.6.2 전개 구문](#162-전개-구문)
    - [1.6.3 객체 초기자](#163-객체-초기자)
    - [1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach](#164-array-프로토타입의-메서드-map-filter-reduce-foreach)
    - [1.6.5 삼항 조건 연산자](#165-삼항-조건-연산자)
    - [1.6.6 정리](#166-정리)
  - [1.7 선택이 아닌 필수, 타입스크립트](#17-선택이-아닌-필수-타입스크립트)
    - [1.7.1 타입스크립트란?](#171-타입스크립트란)
    - [1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법](#172-리액트-코드를-효과적으로-작성하기-위한-타입스크립트-활용법)
    - [1.7.3 타입스크립트 전환 가이드](#173-타입스크립트-전환-가이드)
    - [1.7.4 정리](#174-정리)

<br>

## 1.1 자바스크립트의 동등 비교

### 1.1.1 자바스크립트의 데이터 타입

- number
- string
- boolean
- null
- undefined

- symbol
- bigint (ES2020) -> 124124n (뒤에 n)

- Object

### 1.1.2 값을 저장하는 방식의 차이

- 원시와 객체 타입의 차이 = 값 저장방식이 다름.
- 객체 타입은 주소값이 저장됨.

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is

- === : 같아야함.
- == : 형변환했을때 같으면 됨.
- Object.is(a, b) : ===이 너무엄격해서, 약간더유연. 의도에맞을가능성. (NaN !== NaN 같은 황당한 상황이 없음)

### 1.1.4 리액트에서의 동등 비교

- 리액트는 동등비교시 Object.is(의 폴리필) 사용.
- 그리고 1뎁스 shallowEqual도 사용.
  - jsx의 프롭스 정도만 보면되어서, 1뎁스만 있으면됨.

### 1.1.5 정리

<br>

## 1.2 함수

### 1.2.1 함수란 무엇인가?

### 1.2.2 함수를 정의하는 4가지 방법

- 함수선언문

```javascript
function A(a, b) {}
```

- 함수표현식

```javascript
const A = function (a, b) {};
```

- 사소한차이: 선언문은 호이스팅됨.

  - 표현식은. 변수명은호이스팅되어 TDZ(undefined). 함수 표현식정보는 후에할당됨.

- 둘중 뭘쓸지는 취존. 일관성있게만.

### 1.2.3 다양한 함수 살펴보기

- 화살표함수

```javascript
const add = (a, b) => a + b;
```

- IIFE

```javascript
(function (a, b) {
  return a + b;
})(10, 20); // 30
```

- Function 생성자 (안좋은 낡은방식.)

```javascript
const add = new Function("a", "b", "return a+b");
```

- 고차함수 (함수를 리턴)

### 1.2.4 함수를 만들 때 주의해야 할 사항

- 부수효과를 자제(순수함수)

- 함수를 작게.
  - 줄수 : 50줄이하
  - 뎁스 : 2이하. <-내생각
- 이름 잘붙여
- useEffect 콜백에도 이름붙이면좋다
  - 동의못함.

### 1.2.5 정리

<br>

## 1.3 클래스

### 1.3.1 클래스란 무엇인가?

'#'으로 private가능(ES2019)

### 1.3.2 클래스와 함수의 관계

- 클래스는 생성자함수의 syntactic sugar.
- 바벨로 트랜스파일하면 (ES5) 생성자함수로바뀜.

### 1.3.3 정리

- 사실 FC가 정착된 지금에는 쓸데없는얘기가많다.
- React.Component, React.PureComponent 를 상속하냐의 차이 등..

<br>

## 1.4 클로저

### 1.4.1 클로저의 정의

- 공식정의는 와닿지않고 명확성이떨어짐. 나만의 정의는..
- 일급함수를 넘기면, 외부변수가 사라진후에도 그 당시의 외부변수들에 접근이 가능함.(렉시컬스코프)가 freeze되어 존재하기 때문. 이 현상을 클로저라함

### 1.4.2 변수의 유효 범위, 스코프

### 1.4.3 클로저의 활용

- 전역변수를 쓰면 더티해지기때문에 클로저 활용가능.
- 클래스내부변수가 일종의 정보은닉(Information Hiding)을 하는 역할을 할수있음.

- 개인적 생각은 의식적으로 쓰기엔 별로 유용하진않음.
- 하지만 리액트의 FC환경에서는 항상 사용되고있는존재인 셈.

### 1.4.4 주의할 점

```javascript
X;
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
} // 다 5로 나옴.
```

```javascript
O;
for (let i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
} // 잘나옴
```

var는 레벨스코프라, 전역으로 동작하니까 안됨.
블록스코프인 let을 써줘야함

### 1.4.5 정리

무거운 작업을 클로저로하면, 메모리를 낭비할수있다.

- 너무나도 당연한말..
- 애초에 이 상황은 클로저가 필요하지도않은상황인데 쓴거라..

  <br>

## 1.5 이벤트 루프와 비동기 통신의 이해

### 1.5.1 싱글 스레드 자바스크립트

### 1.5.2 이벤트 루프란?

- 이벤트루프 : 제어를 가진녀석
- setTimeout 과 같은 비동기 코드를 쓰면, 태스크큐에추가될뿐.
  함수가 다 실행되고(호출스택이 다 비워지고)나야
  태스크큐를 보게됨.
- 따라서 setTimeout( , 0)을 걸어도 함수가 다끝나고나야 실행될수있기때문에, 바로 실행을 보장할수없음.

### 1.5.3 태스크 큐와 마이크로 태스크 큐

- 태스크큐는. (매크로) 태스크큐, 마이크로태스크큐 두개가있음.
- 매크로 : I/O, setTimeout, setInterval
- 마이크로 : 프로미스

- 이벤트루프는. 매크로 하나 처리하면, 마이크로 "전부" 를 처리함.

- 이벤트루프 순서
  - 가장오래된 매크로태스크 하나처리
  - 마이크로태스크 모두 실행 ( 다 빌때까지)
  - 렌더링 (있을시)
  - 무한반복

### 1.5.4 정리

<br>

## 1.6 리액트에서 자주 사용하는 자바스크립트 문법

### 1.6.1 구조 분해 할당

기본사용법은 앎.

```javascript
const array = [1, 2];
const [a = 10, b = 20] = array;
```

처럼 default 값도 지원함.

```javascript
const key = "a";
object = {
  a: 1,
  b: 1,
};
const { [key]: a } = object;
```

객체를 구조분해할땐
이렇게 정적키 말고 계산된 키를 사용할수도있음
뒤에 :a는 변수명을 a로 하겠다는뜻.
계산된 키를 사용할경우, 사용할 변수명을 표시해 줘야함.

### 1.6.2 전개 구문

... spread 오퍼레이터 쓰는내용

### 1.6.3 객체 초기자

객체에 {a:a,b:b} 이런식으로 할당할때 \
{a,b}이렇게만 써도된다는내용

### 1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach

그냥쓸줄앎

### 1.6.5 삼항 조건 연산자

사용하면됨
JSX에서는 일반 문법다되는건아니고(for),
표현식만 가능해서 삼항연산자를 많이씀.
하지만 블록으로 쓰고싶으면 아래처럼 IIFE를 이용해서 쓸수있음

```javascript
return <div>
{(()=>{if() for 등..})()
}</div>
```

### 1.6.6 정리

<br>

## 1.7 선택이 아닌 필수, 타입스크립트

### 1.7.1 타입스크립트란?

### 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법

### 1.7.3 타입스크립트 전환 가이드

### 1.7.4 정리

```

```
