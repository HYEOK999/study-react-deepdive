# 01장: 리액트 개발을 위해 꼭 알아야 할 자바스크립트

책을 읽기 전에 자바스크립트에 대한 기본적인 지식을 다루는 장입니다.
이 장에서는 리액트를 사용하면서 자주 사용하는 자바스크립트 문법과 개념을 간단히 정리합니다.

<br>

- [01장: 리액트 개발을 위해 꼭 알아야 할 자바스크립트](#01장-리액트-개발을-위해-꼭-알아야-할-자바스크립트)
  - [1.1 자바스크립트의 동등 비교](#11-자바스크립트의-동등-비교)
    - [1.1.1 자바스크립트의 데이터 타입](#111-자바스크립트의-데이터-타입)
    - [1.1.2 값을 저장하는 방식의 차이](#112-값을-저장하는-방식의-차이)
    - [1.1.3 자바스크립트의 또 다른 비교 공식, Object.is](#113-자바스크립트의-또-다른-비교-공식-objectis)
    - [1.1.4 리액트에서의 동등 비교](#114-리액트에서의-동등-비교)
  - [1.2 함수](#12-함수)
    - [1.2.1 함수란 무엇인가?](#121-함수란-무엇인가)
    - [1.2.2 함수를 정의하는 4가지 방법](#122-함수를-정의하는-4가지-방법)
    - [1.2.3 다양한 함수 살펴보기](#123-다양한-함수-살펴보기)
    - [1.2.4 함수를 만들 때 주의해야 할 사항](#124-함수를-만들-때-주의해야-할-사항)
  - [1.3 클래스](#13-클래스)
  - [1.4 클로저](#14-클로저)
    - [1.4.1 클로저의 정의](#141-클로저의-정의)
    - [1.4.2 변수의 유효 범위, 스코프](#142-변수의-유효-범위-스코프)
    - [1.4.3 클로저의 활용](#143-클로저의-활용)
    - [1.4.4 주의할 점](#144-주의할-점)
  - [1.5 이벤트 루프와 비동기 통신의 이해](#15-이벤트-루프와-비동기-통신의-이해)
    - [1.5.1 싱글 스레드 자바스크립트](#151-싱글-스레드-자바스크립트)
    - [1.5.2 이벤트 루프란?](#152-이벤트-루프란)
    - [1.5.3 태스크 큐와 마이크로 태스크 큐](#153-태스크-큐와-마이크로-태스크-큐)
  - [1.6 리액트에서 자주 사용하는 자바스크립트 문법](#16-리액트에서-자주-사용하는-자바스크립트-문법)
    - [1.6.1 구조 분해 할당](#161-구조-분해-할당)
    - [1.6.2 전개 구문](#162-전개-구문)
    - [1.6.3 객체 초기자](#163-객체-초기자)
    - [1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach](#164-array-프로토타입의-메서드-map-filter-reduce-foreach)
    - [1.6.5 삼항 조건 연산자](#165-삼항-조건-연산자)
  - [1.7 선택이 아닌 필수, 타입스크립트](#17-선택이-아닌-필수-타입스크립트)
    - [1.7.1 타입스크립트란?](#171-타입스크립트란)
    - [1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법](#172-리액트-코드를-효과적으로-작성하기-위한-타입스크립트-활용법)
    - [1.7.3 타입스크립트 전환 가이드](#173-타입스크립트-전환-가이드)

<br>

## 1.1 자바스크립트의 동등 비교

#### 리액트 컴포넌트의 렌더링이 발생하는 이유

- props의 동등 비교에 따른 결과
  - props의 동등 비교는 객체의 얕은 비교를 기반으로 이뤄짐
  - 얕은 비교를 제대로 이해하지 못 하면 렌더링 최적에 어려움을 겪을 가능성이 크다

### 1.1.1 자바스크립트의 데이터 타입

자바스크립트의 데이터 타입은 `원시 타입`과 `객체 타입` 으로 나뉜다.

#### 원시 타입

객체가 아닌 다른 모든 타입

**1. undefined**

- 선언한 후 값을 할당하지 않은 변수
- 값이 주어지지 않은 인수에 자동으로 할당되는 값

**2. null**

- 아직 값이 없거나 비어 있는 값을 표현
- 다른 원시값과 다르게 typeof로 null을 확인했을 때 해당 타입이아닌 'object'로 결과값이 반환됨

> undefined는 선언되었지만 할당되지 않은 값이고, null은 명시적으로 비어있음을 나타내는 값 으로 사용

**3. Boolean**

- 참(true), 거짓(false)만을 가질 수 있는 데이터타입
- true나 false 이외에도 truthy, falsy값이 존재

```javascript
// falsy: 0, NaN, "", null, undefined 등..
// truthy: 조건문 내부에서 true로 취급되는 값, 위에 falsy값 이외에는 모두 true로 취급

if(0){} // false
if(NaN) // false
if(null) // false
if(undefined) //false
if('') // false

if(1){} // true
if('null') // true
if('undefuned') // true
```

**4. Number**

- 진수별로 값을 표현해도 모두 10진수로 해석되어 동일하게 표시

**5. Bigint**

- Number가 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 등장
- 최대 `2^53-1` 까지의 숫자만을 저장할 수 있는 Number와는 달리, Bigint는 더 큰 정수값도 저장할 수 있다.

**6. String**

- 텍스트 타입의 데이터를 저장하기 위해 사용
- 문자열은 원시 타입으로 변경이 불가능

#### 객체 타입

- 7가지 원시 타입 이외의 모든 것이 객체타입 이다. 즉 자바스크립트를 이루고 있는 대부분의 타입이 객체 타입에 속한다
- 배열, 함수, 정규식, 클래스 등이 여기에 포함된다

### 1.1.2 값을 저장하는 방식의 차이

원시 타입과 객체 타입의 주된 차이점은 값을 저장하는 방식에 있다. 이 차이는 동등 비교시에 영향을 미치는 원인이 된다.

- **원시 타입**: 불변 형태의 값으로 저장되며, 변수 할당 시점에 메모리 영영을 차지하고 저장한다

- **객체 타입**: 프로퍼티를 삭제, 추가, 수정할 수 있어 변경 가능한 형태로 저장되며, 참조값이 전달된다

```javascript
let hello = {
  greet: "hello, world",
};

let hi = {
  greet: "hello, world",
};

let hey = hello

1. console.log(hello === hi); // false
2. console.log(hello.greet === hi.greet); //true
3. console.log(hey===hello) // true
```

- 1번은 객체는 값을 저장하는게 아니라 참조를 저장하기 때문에 저장하는 순간 다른 참조를 바라보기 때문에 false이다.
- 2번은 원시값인 내부 속성값을 비교하면 동일하다.
- 3번은 hey와 hello 변수는 변수명 및 각 변수명의 주소가 서로 다르지만 value가 가리키는 주소가 동일해서 true이다

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is

[Object.is mdn](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/is)

**1. `==` (Equality Operator)**

- 값이 동등한지 여부를 검사하고 자동 형 변환이 이뤄짐

**2. `===` (Strict Equality Operator)**

- 값과 타입이 모두 동일한지 여부를 검사
- 형 변환이 없이 엄격한 비교를 수행

**3. `Object.is`**

- 두 값이 같은지 엄격하게 비교
- `===` 와 유사하지만 Object.is가 좀 더 개발자가 기대하는 방식으로 정확히 비교한다

```javascript
-0 === +0; // true
Object.is(-0, 0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
```

위와 같이 특별한 사항에서 ===(동등 비교)가 가지는 한계를 극복하기 위해 만들었으나 여전히 객체 간 비교에 있어서는 ===와 동일하게 동작하는 것을 알 수 있다.

### 1.1.4 리액트에서의 동등 비교

#### [shallowEqual](https://github.com/facebook/react/blob/3e00e58a6ac7f73a3660f31d3129fb06d344167e/packages/shared/shallowEqual.js)

- Object.is로 먼저 비교를 수행한 다음에 Object.is에서 수행하지 못하는 비교, 즉 객체 간 얕은 비교를 한 번 더 수행

- 객체의 얕은 비교만 구현한 이유
  - JSX props는 객체이며, 대부분의 경우 props만 일차적으로 비교하면 충분하다
  - 리액트는 props에서 추출한 값들을 기준으로 렌더링을 수행하므로, 대부분의 상황에서는 얕은 비교로 충분하다

```javascript
// object.is 는 참조가 다른 객체에 대해 비교가 불가능
Object.is({ hello: "world" }, { hello: "world" }); // false
// shallowEqual은 객체의 1 depth까지는 비교가 가능
shallowEqual({ hello: "world" }, { hello: "world" }); // true
// 그러나 2 depth까지 가면 이를 비교할 방법이 없으므로 false를 반환
shallowEqual({ hello: { hi: "world" } }, { hello: { hi: "world" } }); // false
```

<br>

## 1.2 함수

함수형 컴포넌트를 작성할 때 화살표 함수와 일반 함수를 혼재해서 쓰는 경우가 많다. 함수의 다양한 형태와 차이점을 살펴보자

### 1.2.1 함수란 무엇인가?

작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것

### 1.2.2 함수를 정의하는 4가지 방법

#### 1. 함수 선언문

자바스크립트에서 함수를 선언할 때 가장 일반적으로 사용하는 방식

```javascript
function add(a, b) {
  return a + b;
}
```

함수선언식은 호이스팅이 발생한다

- 함수나 블록내부가 아닌 스크립트에서 선언되면 스크립트의 최상위로 끌어올려짐
- 함수나 블록내부에 선언되면 해당 블록 스코프의 최상위로 끌어 올려짐

```javascript
hello(); //hello

function hello() {
  console.log("hello");
}

hello(); // hello
```

> 함수의 호이스팅: 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업

#### 2. 함수 표현식

- 함수를 변수에 할당하는 방식
- 자바스크립트의 함수는 `일급객체`여서 함수 표현식이 가능하다

```javascript
const sum = function (a, b) {
  return a + b;
};
```

var을 사용해서 함수를 변수에 할당하면 변수 선언만 호이스팅이 된다

```javascript
console.log(sum); // ReferenceError: sum is not defined

const sum = function (a, b) {
  return a + b;
};

console.log(multiply); // undefined

var multiply = function (a, b) {
  return a * b;
};
```

> [일급 객체](https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4): 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체

#### 3. Function 생성자

- 함수의 클로저가 생성되지 않아서 권장되지 않은 방식
- eval 처럼 실제 코딩에서 사용되지 않은 방법

```javascript
const add = new Function("a", "b", "return a + b");
```

#### 4. 화살표 함수

- ES6에서 새롭게 추과된 함수 생성 방식
- function이라는 키워드 대신 `=>`를 사용해서 편리하다

```javascript
const add = (a, b) => {
  return a + b;
};

const add = (a, b) => a + b;
```

✅ 앞서 언급한 함수 생성 방식들과의 차이점

**1. constructor 사용 불가능**

- 생성자 함수로 화살표 함수를 사용하는 것은 불가능하다

```javascript
const Car = (name) => {
  this.name = name;
};

// TypeError: Car is not a constructor
const myCar = new Car("하이");
```

**2. argument가 존재하지 않는다**

```javascript
function hello() {
  console.log(arguments);
}

hello(1, 2, 3);
// {
//   '0': 1,
//   '1': 2,
//   '2': 3,
//   length: 3,
//   callee: ƒ hello(),
//   __proto__: {
//     constructor: ƒ Object(),
//     ...
//   }
// }

const hi = () => {
  console.log(arguments);
};

hi(1, 2, 3);
// ReferenceError: arguments is not defined
```

> [arguments](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/arguments): 함수에 전달된 인수에 해당하는 Array 형태의 객체

**3. 함수 자체의 바인딩(this)를 갖지 않는다**

- this는 화살표 함수 이전까지는 함수를 정의할 때가 아니라, 함수가 호출될 때 동적으로 결정된다

- 일반 함수로서 호출된 경우 함수 내부의 this는 전역 객체를 가리키게 된다
- 그러나 화살표는 이와 달리 함수 자체의 바인딩을 갖지 않는다. 화살표 함수 내에서 this를 참조하면 상위 스코프의 this를 따르게 된다.

> [this](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this): 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값

### 1.2.3 다양한 함수 살펴보기

#### 즉시 실행 함수

- 함수를 정의하고 그 순간 즉시 실행되는 함수
- 단 한 번만 호출되고, 다시 호출할 수 없는 함수
- 일반적으로 함수 이름은 생략한다

```javascript
(function (a, b) {
  return a + b;
})(10, 24); // 34

((a, b) => {
  return a + b;
})(10, 24); // 34
```

- 글로벌 스코프를 오염시키지 않아 독립적인 함수 스코프를 운용할 수 있다는 장점이 있다
  - 이 함수는 선언과 동시에 즉시 실행되기 때문에 함수 내부의 값은 해당 함수 외부에서 접근할 수 없다

#### 고차 함수

함수를 인자로 받거나 반환값으로 새로운 함수를 반환시키는 함수

```javascript
const doubledArray = [1, 2, 3].map((item) => item * 2);

doubledArray; // [2,4,6]

// ex) 함수를 반환하는 고차 함수
const add = function (a) {
  //a 가 존재하는 클로저 생성
  return function (b) {
    return a + b;
  };
};

add(1)(3); // 4`	`
```

### 1.2.4 함수를 만들 때 주의해야 할 사항

#### 1. 함수의 부수효과를 최대한 억제하라

부수 효과가 없는 함수를 순수 함수라 한다. 순수 함수는 부수 효과가 없고, 언제 어디서나 어떤 상황에서든 동일한 인수를 받으면 동일한 결과를 반환해야 한다. 또한, 이러한 작동 중에 외부에 어떠한 영향도 미쳐서는 안된다.

그러나 API호출이나 `console.log` 등 웹 앱을 만드는 과정에서 부수 효과를 피할 수 없을 때가 있다. 따라서 함수를 설계할 때는 최대한 억제할 수 있는 방향으로 고려해야 한다. 리액트는 `useEffect`를 작동을 최소화하는 것이 그 일환이라 할 수 있다

> 부수효과: 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것

#### 2. 가능한 한 함수를 작게 만들어라

함수가 짧을수록 코드를 이해하고 유지보수하기 쉬워진다. ESLint의 max-lines-per-function 규칙은 이를 강조하는데, 함수가 너무 길어지지 않도록 유지하는 것이 중요하다.

함수당 코드가 길어지면 내부에서 무슨 일이 일어나는지 추적하기 어려워진다. 또한, 긴 함수는 문제를 일으킬 가능성이 높아지며 재사용성을 저하시킬 수 있다. 따라서 "하나의 함수는 하나의 일을 하고 그 일을 잘 해야 한다(Do One Thing and Do It Well)"는 원칙을 따라 함수를 작게 만들어야 한다

#### 3. 누구나 이해할 수 있는 이름을 붙여라

함수의 이름은 간결하고 이해하기 쉽게 지정하는 것은 클린 코드나 리팩토링 등에서도 많이 다룬다
또한 `useEffect`나 `useCallback`과 같은 훅에 넘겨주는 콜백 함수에도 명확한 이름을 붙히는 것이 좋다.

useEffect와 같은 부수 효과를 일으키는 함수가 늘어날수록, 코드를 읽는 개발자들이 각 함수가 어떤 일을 하는지, 그리고 어떻게 작동하는지 유심히 살펴보지 않더라도 빠르게 이해할 수 있도록 함수에 명확한 이름을 부여하는 것이 도움이 된다.

<br>

## 1.3 클래스

<br>

## 1.4 클로저

### 1.4.1 클로저의 정의

- 함수와 함수가 선언된 어휘적 환경의 조합

> 선언된 어휘적 환경: 변수가 코드 내부에서 어디서 선언됐는지를, this와는 다르게 코드가 작성된 순간에 정작으로 결정된다

### 1.4.2 변수의 유효 범위, 스코프

#### 1. 전역 스코프

- 코드 전체에서 접근할 수 있는 스코프
- 브라우저에서 환경
  - 전역 객체는 `window`
  - Node.js환경에서는 `global`

```javascript
var global = `global scope`;

function hello() {
  console.log(global);
}

console.log(global); // global scope
hello(); // global scope
console.log(global === window.global); // true
```

#### 2. 함수 스코프

- 자바스크립트는 기본적으로 함수 레벨 스코프를 따른다
- {} 블록은 스코프 범위를 결정하지 않고, 자바스크립트에서 스코프는 가장 가까운 스코프에서 변수가 존재하는지 먼저 확인한다

```javascript
var x = 10;
function foo() {
  var x = 100;
  console.log(x); // 100

  function bar() {
    var x = 1000;
    console.log(x); // 1000
  }

  bar();
}

console.log(x); // 10
foo();
```

### 1.4.3 클로저의 활용

- 클로저는 함수가 정의될 때의 스코프에서 외부 변수를 기억하고 접근할 수 있도록 하는 개념
- 이를 활용하여 변수를 은닉하고, 접근을 제한하며 로그를 남기는 다양한 활용이 가능하다

예시 코드에서 클로저를 활용하여 `Counter`함수를 정의하고, 그 안에서 `counter`변수를 은닉하고 접근을 제한하며, `increase`, `decrease`, `counter` 메서드를 통해 조작할 수 있도록 한다

```javascript
function Counter() {
  var counter = 0;

  return {
    increase: function () {
      return ++counter;
    },
    decrease: function () {
      return --counter;
    },
    counter: function () {
      console.log("counter에 접근!");
      return counter;
    },
  };
}

var c = Counter();

console.log(c.increase()); // 1
console.log(c.increase()); // 2
console.log(c.decrease()); // 1
console.log(c.increase()); // 2
console.log(c.counter()); // 2
```

### 1.4.4 주의할 점

- 클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가로 비용이 발생한다
- 클로저 사용을 적절한 스코프로 가둬두지 않으면 성능에 악영향을 미친다
  <br>

## 1.5 이벤트 루프와 비동기 통신의 이해

자바스크립트는 `싱글 스레드`에서 작동한다. 이는한번에 하나의 작업만을 `동기`방식으로 처리한다는 의미다. 그러나 웹 어플리케이션에서는 데이터 fetching 등을 `비동기` 방식으로 처리하고 있다

#### 1. 싱글 스레드

- 자바스크립트는 한 번에 하나의 작업만을 처리하는 싱글 스레드 언어다
- 이는 동시에 여러 작업을 수행하는 다중 스레드 언어와는 다르다

#### 2. 동기

- 동기 방식은 직렬 방식으로 작업을 처리한다
- 한 작업이 끝날 때까지 다음 작업을 실행하지 않는다. 다른 작업을 처리하려면 먼저 이전 작업이 완료되어야 한다

#### 3. 비동기

- 병렬 방식으로 작업을 처리한다
- 한 번에 여러 작업을 실행할 수 있으며, 작업이 완료될 때마다 콜백 함수 등을 활용하여 결과를 처리한다. 이를 통해 다른 작업을 동시에 처리할 수 있습니다.

### 1.5.1 싱글 스레드 자바스크립트

#### 프로세스

- 프로그램을 구동해 프로그램 상태가 메모리상에서 실행되는 작업 단위
- 하나의 프로그램은 하나의 프로세스를 가진다

#### 스레드

- 더 작은 실행단위로, 하나의 프로세스에서는 여러 개의 스레드를 만들 수 있다
- 스레드끼리 메모리를 공유할 수 있어, 여러가지 작업을 동시에 수행할 수 있다

### 1.5.2 이벤트 루프란?

자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치

#### 호출 스택

- 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택

#### 이벤트 루프

### 1.5.3 태스크 큐와 마이크로 태스크 큐

- 이벤트 루프에는 1개의 마이크로 태스크 큐를 가진다
- 기존의 태스크 큐와는 다른 태스크를 처리한다
- 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다 ([ex]`Promise`)
- 마이크로 태스크 큐가 빌 때까지는 기존 태스크 큐의 실행은 뒤로 미뤄진다

> 이벤트 루프는 전체 코드를 실행하고, 호출 스택이 비었을 때 다음과 같은 순서로 작업을 수행한다
> <br>마이크로 태스크 큐 → 렌더링 → 태스크 큐

**태스크 큐**

- setTimeout, setInterval, setImmediate

**마이크로 태스크 큐**

- process.nextTick ,Promise, queueMicroTask, MutationObserver

## 1.6 리액트에서 자주 사용하는 자바스크립트 문법

### 1.6.1 구조 분해 할당

- 배열 또는 객체의 값을 분해해 개별 변수에 즉시 할당하는 방법

#### 1. 배열 구조분해 할당

- 배열의 값을 원하는 변수에 쉽게 할당할 수 있는 방법

**특징**

1. 자유롭게 이름을 선언할 수 있다
2. `,` 의 위치에 따라 값이 결정되기 때문에 중간 인덱스 값을 생략할 수 있다

```javascript
const arr = [1, 2, 3, 4, 5];
const [firts, , , , fifth] = arr;
다;

first; // 1
fifth; // 5
```

3. 기본값을 선언할 수가 있다. 다만 값이 `undefined`일 때만 기본값을 사용된다
4. 특정 값 이후의 값을 다시 배열로 선언하고 싶으면 전개 연산자를 사용할 수 있다. 다만 뒤쪽에서만 사용 가능하다

#### 2. 객체 구조분해 할당

- 객체에서 값을 변수에 할당하는 방법

**특징**

1. 배열 구조 분해 할당과 달리, 객체 내부 이름으로 꺼내온다
2. 새로운 이름으로 다시 할당이 가능하다
3. 기본값을 설정할 수 있다
4. 전개 연산자를 사용할 수 있다

### 1.6.2 전개 구문

배열이나 객체, 문자열과 같이 순회할 수 있는 값에 대해 전개해 간결하게 사용할 수 있는 구문

#### 배열의 전개 구문

- 배열 내부에서 `...배열`을 사용하면 해당 배열을 마치 전개하는 것처럼 선언하고, 이를 내부 배열에서 활용할 수 있다

- 기존 배열에 영향을 미치지 않고 배열을 복사할 수 있다

#### 객체의 전개 구문

- 배열과 비슷하게 사용이 가능하다
- 객체 전개 구문은 순서가 중요하다

### 1.6.3 객체 초기자

객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가 이미 존재한다면 해당 값을 간결하게 넣어줄 수 있는 방식

```javascript
const a = 1;
const b = 2;

const obj = { a, b };
console.log(obj); // { a: 1, b: 2 }
```

### 1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach

### 1.6.5 삼항 조건 연산자

<br>

## 1.7 선택이 아닌 필수, 타입스크립트

동적 언어인 자바스크립트에서 런타임에만 타입을 체크할 수 있는 한계를 극복해 코드를 더욱 안전하게 작성하면서 버그를 줄일 수 있다

### 1.7.1 타입스크립트란?

타입스크립트는 기존 자바스크립트 문법에 타입을 추가한 것으로, 런타임에서만 확인할 수 있는 자바스크립트의 문제점을 보완한다

### 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법

#### 1. any 대신 unknown을 사용하자

`any`는 모든 타입을 허용하는 데 반해, `unknown`은 불확실한 타입을 나타내며 명시적인 타입 체크가 필요한 경우 사용

#### 2. 타입 가드를 적극 활용하자

- instanceof: 지정한 인스턴스가 특정 클래스의 인스턴스인지 확인할 수 있는 연산자
- typeof: 특정 요소에 대해 자료형을 확인하는 데 사용
- in: 어떤 객체에 키가 존재하는지 확인하는 용도

#### 3. 제네릭

- 함수나 클래스 내부에서 단일 타입이 아닌 다양한 타입에 대응할 수 있어 코드의 재사용성을 높일 수 있다

#### 4. 인덱스 시그니처

- 객체의 키를 동적으로 정의하는 방식
- 주로 동적인 객체를 다룰 때 활용

```javascript
type Hello = {
  [key: string]: string,
};

const hello: Hello = {
  hello: "hello",
  hi: "hi",
};

1. hello["hi"]; //hi
2. hello["안녕"]; // undefined
```

인덱스 시그니처를 사용하면 동적인 객체를 생성할 수 있지만, 타입이 넓어져서 특정 키에 대한 타입 체크가 이루어지지 않아 2번 케이스처럼 예상치 못 한 에러가 발생할 수 있다. 이러한 이유로 타입스크립트에서는 가능하면 인덱스 시그니처를 사용하기보다는 명시적인 속성을 선언하는 것이 권장된다

### 1.7.3 타입스크립트 전환 가이드

#### 1. tsconfig.json 먼저 작성하기

#### 2. JSDoc과 @ts-check를 활용해 점진적으로 전환하기

상단에 @ts-check 를 선언하고, JSDoc을 활용하면 변수나 함수에 타입을 제공하면 타입스크립트 컴파일러가 자바스크립트 파일의 타입을 확인한다

#### 3. 타입 기반 라이브러리 사용을 위해 @types 모듈 설치하기

#### 4. 파일 단위로 조금씩 전환하기
