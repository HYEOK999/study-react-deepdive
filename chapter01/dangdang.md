# 01장: 리액트 개발을 위해 꼭 알아야 할 자바스크립트
책을 읽기 전에 자바스크립트에 대한 기본적인 지식을 다루는 장입니다.
이 장에서는 리액트를 사용하면서 자주 사용하는 자바스크립트 문법과 개념을 간단히 정리합니다.

<br>

- [01장: 리액트 개발을 위해 꼭 알아야 할 자바스크립트](#01장-리액트-개발을-위해-꼭-알아야-할-자바스크립트)
  - [1.1 자바스크립트의 동등 비교](#11-자바스크립트의-동등-비교)
    - [1.1.1 자바스크립트의 데이터 타입](#111-자바스크립트의-데이터-타입)
    - [1.1.2 값을 저장하는 방식의 차이](#112-값을-저장하는-방식의-차이)
    - [1.1.3 자바스크립트의 또 다른 비교 공식, Object.is](#113-자바스크립트의-또-다른-비교-공식-objectis)
    - [1.1.4 리액트에서의 동등 비교](#114-리액트에서의-동등-비교)
    - [1.1.5 정리](#115-정리)
  - [1.2 함수](#12-함수)
    - [1.2.1 함수란 무엇인가?](#121-함수란-무엇인가)
    - [1.2.2 함수를 정의하는 4가지 방법](#122-함수를-정의하는-4가지-방법)
    - [1.2.3 다양한 함수 살펴보기](#123-다양한-함수-살펴보기)
    - [1.2.4 함수를 만들 때 주의해야 할 사항](#124-함수를-만들-때-주의해야-할-사항)
    - [1.2.5 정리](#125-정리)
  - [1.3 클래스](#13-클래스)
    - [1.3.1 클래스란 무엇인가?](#131-클래스란-무엇인가)
    - [1.3.2 클래스와 함수의 관계](#132-클래스와-함수의-관계)
    - [1.3.3 정리](#133-정리)
  - [1.4 클로저](#14-클로저)
    - [1.4.1 클로저의 정의](#141-클로저의-정의)
    - [1.4.2 변수의 유효 범위, 스코프](#142-변수의-유효-범위-스코프)
    - [1.4.3 클로저의 활용](#143-클로저의-활용)
    - [1.4.4 주의할 점](#144-주의할-점)
    - [1.4.5 정리](#145-정리)
  - [1.5 이벤트 루프와 비동기 통신의 이해](#15-이벤트-루프와-비동기-통신의-이해)
    - [1.5.1 싱글 스레드 자바스크립트](#151-싱글-스레드-자바스크립트)
    - [1.5.2 이벤트 루프란?](#152-이벤트-루프란)
    - [1.5.3 태스크 큐와 마이크로 태스크 큐](#153-태스크-큐와-마이크로-태스크-큐)
    - [1.5.4 정리](#154-정리)
  - [1.6 리액트에서 자주 사용하는 자바스크립트 문법](#16-리액트에서-자주-사용하는-자바스크립트-문법)
    - [1.6.1 구조 분해 할당](#161-구조-분해-할당)
    - [1.6.2 전개 구문](#162-전개-구문)
    - [1.6.3 객체 초기자](#163-객체-초기자)
    - [1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach](#164-array-프로토타입의-메서드-map-filter-reduce-foreach)
    - [1.6.5 삼항 조건 연산자](#165-삼항-조건-연산자)
    - [1.6.6 정리](#166-정리)
  - [1.7 선택이 아닌 필수, 타입스크립트](#17-선택이-아닌-필수-타입스크립트)
    - [1.7.1 타입스크립트란?](#171-타입스크립트란)
    - [1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법](#172-리액트-코드를-효과적으로-작성하기-위한-타입스크립트-활용법)
    - [1.7.3 타입스크립트 전환 가이드](#173-타입스크립트-전환-가이드)
    - [1.7.4 정리](#174-정리)

<br>

## 1.1 자바스크립트의 동등 비교
### 1.1.1 자바스크립트의 데이터 타입
### 1.1.2 값을 저장하는 방식의 차이
### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is
> ===가 있음에도 Object.is()가 등장한 이유는 NaN 값 비교, -0과 +0의 비교 때문이다.
### 1.1.4 리액트에서의 동등 비교
> 리액트 컴포넌트의 렌더링이 일어나는 이유로 props의 동등 비교가 있으며 이는 객체의 얕은 비교를 기반으로 한다.
> Object.is() 기반의 shallowEqual 함수를 사용한다.
>   > Object.is()는 참조가 다른 객체에 대해 비교가 불가능하나 shallowEqual은 객체의 1 depth까지는 비교가 가능하다.
### 1.1.5 정리

<br>

## 1.2 함수
### 1.2.1 함수란 무엇인가?
### 1.2.2 함수를 정의하는 4가지 방법
> - 함수 선언문
> - 함수 표현식
> - Function 생성자
> - 화살표 함수
### 1.2.3 다양한 함수 살펴보기
> - 즉시 실행 함수
> - 고차 함수
>   > 함수를 인수로 받거나 결과로 새로운 함수를 반환하는 함수
### 1.2.4 함수를 만들 때 주의해야 할 사항
### 1.2.5 정리

<br>

## 1.3 클래스
### 1.3.1 클래스란 무엇인가?
> 생성자
> 프로퍼티
> getter, setter
> 인스턴스 메서드
> 정적 메서드
> 상속
>   > extends 키워드 사용
### 1.3.2 클래스와 함수의 관계
### 1.3.3 정리

<br>

## 1.4 클로저
### 1.4.1 클로저의 정의
> 함수와 함수가 선언된 어휘적 환경의 조합
> 선언된 어휘적 환경: 변수가 코드 내부에서 어디서 선언됐는지를 말함. `this`와 다르게 코드가 작성된 순간 정적으로 결정.
### 1.4.2 변수의 유효 범위, 스코프
### 1.4.3 클로저의 활용
### 1.4.4 주의할 점
### 1.4.5 정리

<br>

## 1.5 이벤트 루프와 비동기 통신의 이해
### 1.5.1 싱글 스레드 자바스크립트
### 1.5.2 이벤트 루프란?
> 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택
### 1.5.3 태스크 큐와 마이크로 태스크 큐
### 1.5.4 정리

<br>

## 1.6 리액트에서 자주 사용하는 자바스크립트 문법
### 1.6.1 구조 분해 할당
```javascript
const array = [1, 2, 3, 4, 5]

// 1. 각 변수에 할당
const [first, second, third, ...arrayRest] = array
// 2. ,의 위치에 따라 값이 결정된다
const [first, , , , fifth] = array // 2,3,4는 아무런 표현식이 없어 변수 할당 생략

// 3. 초기값 설정 -> 실수 유발 가능성 높음
const array2 = [1, 2]
const [a = 10, b = 20, c = 30] = array2

// 4. undefined일 때만 기본 값을 사용한다
const [a = 1, b = 1, c = 1, d = 1, e = 1] = [undefined, null, 0, '']
// a 1
// b null
// c 0
// d ''
// e 1
```


```javascript
// 새로운 이름으로 다시 할당하는 것 가능
const object = {
  a: 1,
  b: 2,
}

const { a: first, b: second } = object
// first 1
// second 2

// 계산된 속성 이름 방식으로 꺼내오기 가능
const key = 'a'
const object = {
  a: 1,
  b: 2,
}

const { [key]: a } = object

// a = 1
// a라는 값을 거내 오기 위해 [key] 문법을 사용하고, 반드시 이름을 선언하는 :a와 같은 변수 네이밍이 필요함
```


### 1.6.2 전개 구문
> 배열 전개
```javascript
const obj1 = {
  a: 1,
  b: 2,
}

const obj2 = {
  c: 3,
  d: 4,
}

const newObj = { ...obj1, ...obj2 }
// { "a": 1, "b": 2, "c": 3, "d": 4 }
```
> 객체 전개
```javascript
const arr1 = ['a', 'b']
const arr2 = [...arr1, 'c', 'd', 'e'] // ['a', 'b', 'c', 'd', 'e']

const arr1 = ['a', 'b']
const arr2 = arr1

arr1 === arr2; // true. 내용이 아닌 참조를 복사함

const arr1 = ['a', 'b']
const arr2 = [...arr1]

arr1 === arr2 // false. 실제로 값만 복사될 뿐, 참조는 다름
```
### 1.6.3 객체 초기자
```javascript
const a = 1
const b = 2

const obj = {
  a,
  b,
}

// {a : 1, b : 2}
```
### 1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach
### 1.6.5 삼항 조건 연산자
### 1.6.6 정리

<br>

## 1.7 선택이 아닌 필수, 타입스크립트
### 1.7.1 타입스크립트란?
### 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법
### 1.7.3 타입스크립트 전환 가이드
### 1.7.4 정리